<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Family Tree</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f9fa;
        }
        
        .welcome-page {
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 2rem;
        }
        
        .tree-container {
            height: calc(100vh - 60px);
            overflow: hidden;
            position: relative;
        }
        
        .page {
            display: none;
        }
        
        .page.active {
            display: block;
        }
        
        .form-page {
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .profile-page {
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .tree-toolbar {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 100;
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        
        .preview-image {
            width: 150px;
            height: 150px;
            object-fit: cover;
            border-radius: 5px;
        }
        
        .node {
            cursor: pointer;
        }
        
        .node-male {
            fill: #5D9CEC;
            stroke: #4A89DC;
            stroke-width: 2px;
        }
        
        .node-female {
            fill: #EC87C0;
            stroke: #D770AD;
            stroke-width: 2px;
        }
        
        .node-unknown {
            fill: #AAB2BD;
            stroke: #656D78;
            stroke-width: 2px;
        }
        
        .node-year-label {
            text-anchor: middle;
            font-size: 12px;
            font-weight: bold;
            fill: #333;
            background-color: rgba(255, 255, 255, 0.7);
        }
        
        .delete-button {
            cursor: pointer;
            fill: #e74c3c;
            font-weight: bold;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .family-node:hover .delete-button {
            opacity: 1;
        }
        
        .tree-link {
            fill: none;
            stroke: #656D78;
            stroke-width: 2px;
        }
        
        .marriage-link {
            fill: none;
            stroke: #8e44ad;
            stroke-width: 2px;
        }
        
        .profile-header {
            display: flex;
            margin-bottom: 2rem;
        }
        
        .profile-picture {
            width: 150px;
            height: 150px;
            object-fit: cover;
            border-radius: 5px;
            margin-right: 2rem;
        }
        
        .profile-info {
            flex: 1;
        }
        
        .relationship-title {
            margin-top: 2rem;
            font-weight: bold;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #ddd;
        }
        
        .relationship-item {
            margin: 1rem 0;
            padding: 0.5rem;
            background-color: #f8f9fa;
            border-radius: 5px;
            cursor: pointer;
        }
        
        .relationship-item:hover {
            background-color: #e9ecef;
        }
        
        .family-node text {
            text-anchor: middle;
            dominant-baseline: middle;
            font-size: 12px;
            font-weight: bold;
            fill: #fff;
        }
        
        .family-node-label {
            text-anchor: middle;
            font-size: 12px;
            font-weight: bold;
            fill: #333;
        }
        
        .save-notice {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .save-notice.show {
            opacity: 1;
        }
        
        .person-photo {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid white;
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #ffffff;
        }
        
        .add-member-floating {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: #5D9CEC;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            z-index: 100;
            font-size: 24px;
            cursor: pointer;
        }
        
        .relationship-section {
            margin-bottom: 20px;
            border: 1px solid #eee;
            border-radius: 5px;
            padding: 15px;
            background-color: #f9f9f9;
        }
        
        .relationship-section-title {
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .tree-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background-color: #f8f9fa;
            padding: 10px 20px;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 90;
        }
        
        .tree-container.with-header {
            padding-top: 60px;
        }
    </style>
</head>
<body>
    <!-- Welcome Page -->
    <div id="welcome-page" class="page welcome-page active">
        <svg width="200" height="200" viewBox="0 0 200 200" class="mb-4">
            <style>
                .tree-trunk { fill: #8B4513; }
                .tree-leaves { fill: #228B22; }
            </style>
            <rect class="tree-trunk" x="95" y="140" width="10" height="40"/>
            <circle class="tree-leaves" cx="100" cy="90" r="60"/>
            <path class="tree-leaves" d="M100,140 C70,120 30,120 20,80 C10,40 70,20 100,40 C130,20 190,40 180,80 C170,120 130,120 100,140 Z"/>
        </svg>
        <h1 class="display-4 mb-4">Welcome to Your Family Tree</h1>
        <p class="lead mb-5">A simple way to create and view your family connections</p>
        
        <div id="storage-options" class="mb-4">
            <div class="d-flex flex-column gap-3">
                <button id="start-button" class="btn btn-primary btn-lg">
                    <i class="fas fa-arrow-right me-2"></i>Start
                </button>
                <button id="import-button" class="btn btn-outline-primary">
                    <i class="fas fa-file-import me-2"></i>Import Existing Data
                </button>
                <input type="file" id="import-file" accept=".json" class="d-none">
            </div>
        </div>
    </div>
    
    <!-- Add Member Form -->
    <div id="form-page" class="page form-page">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <h2 class="mb-0">Add Family Member</h2>
            <button id="back-to-tree-from-form" class="btn btn-outline-secondary">
                <i class="fas fa-arrow-left me-2"></i>Back to Tree
            </button>
        </div>
        
        <div id="success-alert" class="alert alert-success d-none" role="alert">
            Family member added successfully!
        </div>
        
        <form id="member-form">
            <div class="card mb-4">
                <div class="card-header">Personal Information</div>
                <div class="card-body">
                    <div class="row mb-3">
                        <div class="col-md-4">
                            <label for="firstName" class="form-label">First Name</label>
                            <input type="text" class="form-control" id="firstName">
                        </div>
                        <div class="col-md-4">
                            <label for="middleName" class="form-label">Middle Name</label>
                            <input type="text" class="form-control" id="middleName">
                        </div>
                        <div class="col-md-4">
                            <label for="lastName" class="form-label">Last Name</label>
                            <input type="text" class="form-control" id="lastName">
                        </div>
                    </div>
                    
                    <div class="row mb-3">
                        <div class="col-md-4">
                            <label for="gender" class="form-label">Gender</label>
                            <select class="form-select" id="gender">
                                <option value="" selected>Select gender</option>
                                <option value="male">Male</option>
                                <option value="female">Female</option>
                                <option value="other">Other</option>
                            </select>
                        </div>
                        <div class="col-md-4">
                            <label for="birthYear" class="form-label">Birth Year</label>
                            <input type="number" class="form-control" id="birthYear" placeholder="YYYY">
                        </div>
                        <div class="col-md-4">
                            <label for="deathYear" class="form-label">Death Year (if applicable)</label>
                            <input type="number" class="form-control" id="deathYear" placeholder="YYYY">
                        </div>
                    </div>
                    
                    <div class="mb-3">
                        <label class="form-label">Photo</label>
                        <input type="file" class="form-control" id="photoInput" accept="image/*">
                        <div class="mt-2" id="photoPreviewContainer">
                            <img id="photoPreview" class="preview-image d-none">
                        </div>
                    </div>
                    
                    <div class="mb-3">
                        <label for="birthplace" class="form-label">Birthplace</label>
                        <input type="text" class="form-control" id="birthplace">
                    </div>
                    
                    <div class="mb-3">
                        <label for="occupation" class="form-label">Occupation</label>
                        <input type="text" class="form-control" id="occupation">
                    </div>
                    
                    <div class="mb-3">
                        <label for="notes" class="form-label">Notes</label>
                        <textarea class="form-control" id="notes" rows="3"></textarea>
                    </div>
                </div>
            </div>
            
            <div class="card mb-4">
                <div class="card-header">Family Relationships</div>
                <div class="card-body">
                    <!-- Parents Section -->
                    <div class="relationship-section">
                        <div class="relationship-section-title">Parents</div>
                        <div class="mb-3">
                            <label for="parentSelect" class="form-label">Add Parent</label>
                            <div class="input-group">
                                <select class="form-select" id="parentSelect">
                                    <option value="" selected>Select parent</option>
                                    <!-- Will be populated by JavaScript -->
                                </select>
                                <select class="form-select" id="parentRelationship">
                                    <option value="biological">Biological</option>
                                    <option value="adoptive">Adoptive</option>
                                    <option value="step">Step</option>
                                    <option value="foster">Foster</option>
                                </select>
                                <button class="btn btn-outline-primary" type="button" id="addParentBtn">Add</button>
                            </div>
                            <div id="parentsList" class="mt-2">
                                <!-- Parents will be listed here -->
                            </div>
                        </div>
                    </div>
                    
                    <!-- Spouses Section -->
                    <div class="relationship-section">
                        <div class="relationship-section-title">Partners/Spouses</div>
                        <div class="mb-3">
                            <label for="spouseSelect" class="form-label">Add Spouse/Partner</label>
                            <div class="input-group">
                                <select class="form-select" id="spouseSelect">
                                    <option value="" selected>Select spouse/partner</option>
                                    <!-- Will be populated by JavaScript -->
                                </select>
                                <select class="form-select" id="relationshipType">
                                    <option value="married">Married</option>
                                    <option value="divorced">Divorced</option>
                                    <option value="partner">Partner</option>
                                    <option value="separated">Separated</option>
                                </select>
                                <button class="btn btn-outline-primary" type="button" id="addSpouseBtn">Add</button>
                            </div>
                            <div id="spousesList" class="mt-2">
                                <!-- Spouses will be listed here -->
                            </div>
                        </div>
                    </div>
                    
                    <!-- Siblings Section -->
                    <div class="relationship-section">
                        <div class="relationship-section-title">Siblings</div>
                        <div class="mb-3">
                            <label for="siblingSelect" class="form-label">Add Sibling</label>
                            <div class="input-group">
                                <select class="form-select" id="siblingSelect">
                                    <option value="" selected>Select sibling</option>
                                    <!-- Will be populated by JavaScript -->
                                </select>
                                <select class="form-select" id="siblingRelationship">
                                    <option value="full">Full Sibling</option>
                                    <option value="half">Half Sibling</option>
                                    <option value="step">Step Sibling</option>
                                    <option value="adoptive">Adoptive Sibling</option>
                                </select>
                                <button class="btn btn-outline-primary" type="button" id="addSiblingBtn">Add</button>
                            </div>
                            <div id="siblingsList" class="mt-2">
                                <!-- Siblings will be listed here -->
                            </div>
                        </div>
                    </div>
                    
                    <!-- Children Section -->
                    <div class="relationship-section">
                        <div class="relationship-section-title">Children</div>
                        <div class="mb-3">
                            <label for="childSelect" class="form-label">Add Child</label>
                            <div class="input-group">
                                <select class="form-select" id="childSelect">
                                    <option value="" selected>Select child</option>
                                    <!-- Will be populated by JavaScript -->
                                </select>
                                <select class="form-select" id="childRelationship">
                                    <option value="biological">Biological</option>
                                    <option value="adoptive">Adoptive</option>
                                    <option value="step">Step</option>
                                    <option value="foster">Foster</option>
                                </select>
                                <button class="btn btn-outline-primary" type="button" id="addChildBtn">Add</button>
                            </div>
                            <div id="childrenList" class="mt-2">
                                <!-- Children will be listed here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="d-flex justify-content-between">
                <button type="button" id="cancel-button" class="btn btn-outline-secondary">Cancel</button>
                <div>
                    <button type="button" id="reset-button" class="btn btn-outline-secondary me-2">Reset</button>
                    <button type="button" id="save-button" class="btn btn-primary">Save Family Member</button>
                </div>
            </div>
        </form>
    </div>
    
    <!-- Tree View -->
    <div id="tree-page" class="page">
        <div class="tree-header">
            <h3>Family Tree</h3>
            <div class="d-flex gap-2">
                <button id="add-member-button" class="btn btn-primary">
                    <i class="fas fa-plus me-2"></i>Add Member
                </button>
                <button id="export-button" class="btn btn-outline-primary">
                    <i class="fas fa-download me-2"></i>Export
                </button>
                <button id="organize-tree-button" class="btn btn-outline-secondary">
                    <i class="fas fa-sitemap me-2"></i>Organize Tree
                </button>
            </div>
        </div>
        
        <div class="tree-toolbar">
            <button id="zoom-in-button" class="btn btn-sm btn-outline-secondary">
                <i class="fas fa-search-plus"></i>
            </button>
            <button id="zoom-out-button" class="btn btn-sm btn-outline-secondary">
                <i class="fas fa-search-minus"></i>
            </button>
            <button id="center-tree-button" class="btn btn-sm btn-outline-secondary">
                <i class="fas fa-compress-arrows-alt"></i>
            </button>
        </div>
        
        <div id="tree-container" class="tree-container with-header">
            <!-- Tree will be rendered here -->
        </div>
        
        <div class="add-member-floating" id="add-member-floating">
            <i class="fas fa-plus"></i>
        </div>
        
        <div id="relationship-finder" class="card position-fixed bottom-0 start-0 end-0 mb-0" style="z-index: 1000; display: none;">
            <div class="card-header d-flex justify-content-between align-items-center bg-light">
                <h5 class="mb-0">Find Relationship</h5>
                <button type="button" class="btn-close" id="close-relationship-finder"></button>
            </div>
            <div class="card-body">
                <div class="row g-3">
                    <div class="col-md-5">
                        <label for="person1Select" class="form-label">First Person</label>
                        <select class="form-select" id="person1Select">
                            <option value="" selected>Select person</option>
                        </select>
                    </div>
                    <div class="col-md-5">
                        <label for="person2Select" class="form-label">Second Person</label>
                        <select class="form-select" id="person2Select">
                            <option value="" selected>Select person</option>
                        </select>
                    </div>
                    <div class="col-md-2 d-flex align-items-end">
                        <button id="find-relationship-btn" class="btn btn-primary w-100">Find Relationship</button>
                    </div>
                </div>
                <div id="relationship-result" class="mt-3">
                    <!-- Relationship results will be displayed here -->
                </div>
            </div>
        </div>
        
        <div class="position-fixed bottom-0 end-0 mb-3 me-3" style="z-index: 1000;">
            <button id="toggle-relationship-finder" class="btn btn-primary me-2">
                <i class="fas fa-people-arrows me-2"></i>Find Relationship
            </button>
        </div>
        
        <div id="save-notice" class="save-notice">Data saved to localStorage</div>
    </div>
    
    <!-- Profile View -->
    <div id="profile-page" class="page profile-page">
        <div id="profile-container">
            <!-- Will be populated by JavaScript -->
        </div>
        
        <div class="mt-4">
            <button id="back-to-tree-button" class="btn btn-outline-secondary">Back to Tree</button>
            <button id="edit-profile-button" class="btn btn-primary float-end">Edit</button>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script>
        // Main application
        const familyTreeApp = {
            // Data
            members: [],
            relationships: [],
            currentMember: null,
            zoomLevel: 1,
            
            // Pages
            pages: {
                welcome: document.getElementById('welcome-page'),
                form: document.getElementById('form-page'),
                tree: document.getElementById('tree-page'),
                profile: document.getElementById('profile-page')
            },
            
            // Initialize the application
            init: function() {
                this.loadData();
                this.setupEventListeners();
                this.populateMemberSelectors();
                
                if (this.members.length > 0) {
                    this.showPage('tree');
                    this.renderTree();
                }
            },
            
            // Load data from localStorage
            loadData: function() {
                try {
                    const membersData = localStorage.getItem('familyTreeMembers');
                    const relationshipsData = localStorage.getItem('familyTreeRelationships');
                    
                    if (membersData) {
                        this.members = JSON.parse(membersData);
                    }
                    
                    if (relationshipsData) {
                        this.relationships = JSON.parse(relationshipsData);
                    }
                } catch (error) {
                    console.error('Error loading data from localStorage:', error);
                    // If there's an error, start with empty data
                    this.members = [];
                    this.relationships = [];
                }
            },
            
            // Save data to localStorage
            saveData: function() {
                try {
                    localStorage.setItem('familyTreeMembers', JSON.stringify(this.members));
                    localStorage.setItem('familyTreeRelationships', JSON.stringify(this.relationships));
                    
                    // Show save notice
                    const saveNotice = document.getElementById('save-notice');
                    saveNotice.classList.add('show');
                    
                    // Hide notice after 2 seconds
                    setTimeout(() => {
                        saveNotice.classList.remove('show');
                    }, 2000);
                    
                    return true;
                } catch (error) {
                    console.error('Error saving data to localStorage:', error);
                    alert('Could not save data to localStorage. Your browser might have storage restrictions or you might be in incognito mode.');
                    return false;
                }
            },
            
            // Export data as file
            exportData: function() {
                const data = {
                    members: this.members,
                    relationships: this.relationships,
                    exportDate: new Date().toISOString()
                };
                
                const jsonData = JSON.stringify(data, null, 2);
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `family_tree_${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            },
            
            // Import data from file
            importData: function(jsonData) {
                try {
                    const data = JSON.parse(jsonData);
                    
                    if (data.members && Array.isArray(data.members) && 
                        data.relationships && Array.isArray(data.relationships)) {
                        this.members = data.members;
                        this.relationships = data.relationships;
                        this.saveData();
                        this.populateMemberSelectors();
                        this.renderTree();
                        return true;
                    }
                } catch (error) {
                    console.error('Error importing data:', error);
                }
                
                return false;
            },
            
            // Setup event listeners
            setupEventListeners: function() {
                // Welcome page
                document.getElementById('start-button').addEventListener('click', () => {
                    this.showPage('form');
                });
                
                // Import
                document.getElementById('import-button').addEventListener('click', () => {
                    document.getElementById('import-file').click();
                });
                
                document.getElementById('import-file').addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        const file = e.target.files[0];
                        const reader = new FileReader();
                        
                        reader.onload = (event) => {
                            if (this.importData(event.target.result)) {
                                alert('Data imported successfully!');
                                this.showPage('tree');
                            } else {
                                alert('Error importing data. Please check file format.');
                            }
                        };
                        
                        reader.readAsText(file);
                    }
                });
                
                // Form page
                document.getElementById('back-to-tree-from-form').addEventListener('click', () => {
                    if (this.members.length > 0) {
                        this.showPage('tree');
                    } else {
                        this.showPage('welcome');
                    }
                });
                
                document.getElementById('cancel-button').addEventListener('click', () => {
                    if (this.members.length > 0) {
                        this.showPage('tree');
                    } else {
                        this.showPage('welcome');
                    }
                });
                
                document.getElementById('reset-button').addEventListener('click', () => {
                    this.resetForm();
                });
                
                document.getElementById('save-button').addEventListener('click', () => {
                    this.saveMember();
                });
                
                // Relationship finder
                document.getElementById('toggle-relationship-finder').addEventListener('click', () => {
                    const finderPanel = document.getElementById('relationship-finder');
                    if (finderPanel.style.display === 'none') {
                        finderPanel.style.display = 'block';
                        this.populateRelationshipFinderSelects();
                    } else {
                        finderPanel.style.display = 'none';
                    }
                });
                
                document.getElementById('close-relationship-finder').addEventListener('click', () => {
                    document.getElementById('relationship-finder').style.display = 'none';
                });
                
                document.getElementById('find-relationship-btn').addEventListener('click', () => {
                    this.findRelationship();
                });
                
                // Photo preview
                document.getElementById('photoInput').addEventListener('change', (e) => {
                    if (e.target.files && e.target.files[0]) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            const photoPreview = document.getElementById('photoPreview');
                            photoPreview.src = event.target.result;
                            photoPreview.classList.remove('d-none');
                        };
                        reader.readAsDataURL(e.target.files[0]);
                    }
                });
                
                // Relationship buttons
                document.getElementById('addParentBtn').addEventListener('click', () => {
                    const parentSelect = document.getElementById('parentSelect');
                    const relationshipType = document.getElementById('parentRelationship').value;
                    
                    if (parentSelect.value) {
                        const parent = this.members.find(m => m.id === parentSelect.value);
                        if (parent) {
                            this.addRelationshipToForm('parent', parent, relationshipType);
                            parentSelect.value = '';
                        }
                    }
                });
                
                document.getElementById('addSpouseBtn').addEventListener('click', () => {
                    const spouseSelect = document.getElementById('spouseSelect');
                    const relationshipType = document.getElementById('relationshipType').value;
                    
                    if (spouseSelect.value) {
                        const spouse = this.members.find(m => m.id === spouseSelect.value);
                        if (spouse) {
                            this.addRelationshipToForm('spouse', spouse, relationshipType);
                            spouseSelect.value = '';
                        }
                    }
                });
                
                document.getElementById('addSiblingBtn').addEventListener('click', () => {
                    const siblingSelect = document.getElementById('siblingSelect');
                    const relationshipType = document.getElementById('siblingRelationship').value;
                    
                    if (siblingSelect.value) {
                        const sibling = this.members.find(m => m.id === siblingSelect.value);
                        if (sibling) {
                            this.addRelationshipToForm('sibling', sibling, relationshipType);
                            siblingSelect.value = '';
                        }
                    }
                });
                
                document.getElementById('addChildBtn').addEventListener('click', () => {
                    const childSelect = document.getElementById('childSelect');
                    const relationshipType = document.getElementById('childRelationship').value;
                    
                    if (childSelect.value) {
                        const child = this.members.find(m => m.id === childSelect.value);
                        if (child) {
                            this.addRelationshipToForm('child', child, relationshipType);
                            childSelect.value = '';
                        }
                    }
                });
                
                // Tree page
                document.getElementById('add-member-button').addEventListener('click', () => {
                    this.resetForm();
                    this.showPage('form');
                });
                
                document.getElementById('add-member-floating').addEventListener('click', () => {
                    this.resetForm();
                    this.showPage('form');
                });
                
                document.getElementById('export-button').addEventListener('click', () => {
                    this.exportData();
                });
                
                document.getElementById('organize-tree-button').addEventListener('click', () => {
                    this.renderTree(true);
                });
                
                document.getElementById('zoom-in-button').addEventListener('click', () => {
                    this.zoomTree(0.2);
                });
                
                document.getElementById('zoom-out-button').addEventListener('click', () => {
                    this.zoomTree(-0.2);
                });
                
                document.getElementById('center-tree-button').addEventListener('click', () => {
                    this.centerTree();
                });
                
                // Profile page
                document.getElementById('back-to-tree-button').addEventListener('click', () => {
                    this.showPage('tree');
                });
                
                document.getElementById('edit-profile-button').addEventListener('click', () => {
                    if (this.currentMember) {
                        this.populateFormForEdit(this.currentMember);
                        this.showPage('form');
                    }
                });
            },
            
            // Show a specific page
            showPage: function(pageName) {
                Object.values(this.pages).forEach(page => {
                    page.classList.remove('active');
                });
                
                if (this.pages[pageName]) {
                    this.pages[pageName].classList.add('active');
                    
                    if (pageName === 'tree') {
                        this.renderTree();
                    }
                }
            },
            
            // Reset the form
            resetForm: function() {
                document.getElementById('member-form').reset();
                
                document.getElementById('photoPreview').classList.add('d-none');
                document.getElementById('parentsList').innerHTML = '';
                document.getElementById('spousesList').innerHTML = '';
                document.getElementById('siblingsList').innerHTML = '';
                document.getElementById('childrenList').innerHTML = '';
                
                document.getElementById('save-button').textContent = 'Save Family Member';
                document.getElementById('save-button').dataset.editing = '';
            },
            
            // Save a new member or update existing
            saveMember: function() {
                const firstName = document.getElementById('firstName').value.trim();
                const middleName = document.getElementById('middleName').value.trim();
                const lastName = document.getElementById('lastName').value.trim();
                const gender = document.getElementById('gender').value;
                const birthYear = document.getElementById('birthYear').value;
                const deathYear = document.getElementById('deathYear').value;
                const birthplace = document.getElementById('birthplace').value.trim();
                const occupation = document.getElementById('occupation').value.trim();
                const notes = document.getElementById('notes').value.trim();
                
                // Basic validation
                if (!firstName && !lastName) {
                    alert('Please enter at least a first or last name');
                    return;
                }
                
                // Get photo if uploaded
                const photoPreview = document.getElementById('photoPreview');
                const photo = photoPreview.classList.contains('d-none') ? '' : photoPreview.src;
                
                // Create member object
                const member = {
                    firstName,
                    middleName,
                    lastName,
                    gender,
                    birthYear,
                    deathYear,
                    birthplace,
                    occupation,
                    notes,
                    photo
                };
                
                // Get relationship data
                const parentItems = Array.from(document.querySelectorAll('#parentsList [data-id]'));
                const parentRelationships = parentItems.map(el => ({
                    id: el.dataset.id,
                    type: el.dataset.relationshipType || 'biological'
                }));
                
                const spouseItems = Array.from(document.querySelectorAll('#spousesList [data-id]'));
                const spouseRelationships = spouseItems.map(el => ({
                    id: el.dataset.id,
                    type: el.dataset.relationshipType || 'married'
                }));
                
                const siblingItems = Array.from(document.querySelectorAll('#siblingsList [data-id]'));
                const siblingRelationships = siblingItems.map(el => ({
                    id: el.dataset.id,
                    type: el.dataset.relationshipType || 'full'
                }));
                
                const childItems = Array.from(document.querySelectorAll('#childrenList [data-id]'));
                const childRelationships = childItems.map(el => ({
                    id: el.dataset.id,
                    type: el.dataset.relationshipType || 'biological'
                }));
                
                // Check if editing or adding new
                const editingId = document.getElementById('save-button').dataset.editing;
                
                if (editingId) {
                    member.id = editingId;
                    this.updateMember(member);
                    
                    // Remove old relationships
                    this.relationships = this.relationships.filter(r => 
                        !(r.from === editingId && (r.type === 'parent' || r.type === 'child' || r.type === 'sibling')) && 
                        !(r.to === editingId && (r.type === 'parent' || r.type === 'child' || r.type === 'sibling')) &&
                        !((r.from === editingId || r.to === editingId) && r.type === 'spouse')
                    );
                } else {
                    member.id = this.generateUniqueId();
                    this.members.push(member);
                }
                
                // Add parent relationships
                parentRelationships.forEach(rel => {
                    this.relationships.push({
                        from: rel.id,
                        to: member.id,
                        type: 'parent',
                        relationshipType: rel.type
                    });
                });
                
                // Add spouse relationships
                spouseRelationships.forEach(rel => {
                    this.relationships.push({
                        from: member.id,
                        to: rel.id,
                        type: 'spouse',
                        relationshipType: rel.type
                    });
                });
                
                // Add sibling relationships
                siblingRelationships.forEach(rel => {
                    this.relationships.push({
                        from: member.id,
                        to: rel.id,
                        type: 'sibling',
                        relationshipType: rel.type
                    });
                });
                
                // Add child relationships
                childRelationships.forEach(rel => {
                    this.relationships.push({
                        from: member.id,
                        to: rel.id,
                        type: 'parent', // Parent relationship type to indicate parent->child
                        relationshipType: rel.type
                    });
                });
                
                // Save data
                this.saveData();
                
                // Show success message
                const successAlert = document.getElementById('success-alert');
                successAlert.classList.remove('d-none');
                successAlert.textContent = editingId ? 'Family member updated successfully!' : 'Family member added successfully!';
                
                setTimeout(() => {
                    successAlert.classList.add('d-none');
                }, 3000);
                
                // Update UI
                this.populateMemberSelectors();
                this.resetForm();
                this.showPage('tree');
            },
            
            // Update an existing member
            updateMember: function(member) {
                const index = this.members.findIndex(m => m.id === member.id);
                if (index !== -1) {
                    this.members[index] = member;
                    this.saveData();
                }
            },
            
            // Add relationship to the form
            addRelationshipToForm: function(type, person, relationshipType) {
                let listElement;
                
                switch(type) {
                    case 'parent':
                        listElement = document.getElementById('parentsList');
                        break;
                    case 'spouse':
                        listElement = document.getElementById('spousesList');
                        break;
                    case 'sibling':
                        listElement = document.getElementById('siblingsList');
                        break;
                    case 'child':
                        listElement = document.getElementById('childrenList');
                        break;
                    default:
                        return;
                }
                
                // Check if already added
                if (listElement.querySelector(`[data-id="${person.id}"]`)) {
                    return;
                }
                
                const item = document.createElement('div');
                item.className = 'alert alert-secondary d-flex justify-content-between align-items-center';
                item.dataset.id = person.id;
                item.dataset.relationshipType = relationshipType;
                
                // Format relationship type for display
                let relationshipDisplay = relationshipType;
                if (relationshipType) {
                    relationshipDisplay = relationshipType.charAt(0).toUpperCase() + relationshipType.slice(1);
                }
                
                item.innerHTML = `
                    <div>
                        <strong>${this.getDisplayName(person)}</strong>
                        ${relationshipType ? `<span class="badge bg-info ms-2">${relationshipDisplay}</span>` : ''}
                    </div>
                    <button type="button" class="btn-close"></button>
                `;
                
                listElement.appendChild(item);
                
                // Add remove event
                item.querySelector('.btn-close').addEventListener('click', () => {
                    item.remove();
                });
            },
            
            // Populate member selectors for relationships
            populateMemberSelectors: function() {
                const selectors = {
                    parent: document.getElementById('parentSelect'),
                    spouse: document.getElementById('spouseSelect'),
                    sibling: document.getElementById('siblingSelect'),
                    child: document.getElementById('childSelect')
                };
                
                // Clear existing options except first
                Object.values(selectors).forEach(selector => {
                    if (!selector) return;
                    while (selector.options.length > 1) selector.remove(1);
                });
                
                // Add members as options
                this.members.forEach(member => {
                    const option = document.createElement('option');
                    option.value = member.id;
                    option.textContent = this.getDisplayName(member);
                    
                    Object.values(selectors).forEach(selector => {
                        if (selector) {
                            selector.appendChild(option.cloneNode(true));
                        }
                    });
                });
            },
            
            // Populate form for editing
            populateFormForEdit: function(member) {
                document.getElementById('firstName').value = member.firstName || '';
                document.getElementById('middleName').value = member.middleName || '';
                document.getElementById('lastName').value = member.lastName || '';
                document.getElementById('gender').value = member.gender || '';
                document.getElementById('birthYear').value = member.birthYear || '';
                document.getElementById('deathYear').value = member.deathYear || '';
                document.getElementById('birthplace').value = member.birthplace || '';
                document.getElementById('occupation').value = member.occupation || '';
                document.getElementById('notes').value = member.notes || '';
                
                // Set photo if exists
                const photoPreview = document.getElementById('photoPreview');
                if (member.photo) {
                    photoPreview.src = member.photo;
                    photoPreview.classList.remove('d-none');
                } else {
                    photoPreview.classList.add('d-none');
                }
                
                // Clear existing relationships
                document.getElementById('parentsList').innerHTML = '';
                document.getElementById('spousesList').innerHTML = '';
                document.getElementById('siblingsList').innerHTML = '';
                document.getElementById('childrenList').innerHTML = '';
                
                // Add parents
                this.relationships
                    .filter(r => r.to === member.id && r.type === 'parent')
                    .forEach(r => {
                        const parent = this.members.find(m => m.id === r.from);
                        if (parent) {
                            this.addRelationshipToForm('parent', parent, r.relationshipType);
                        }
                    });
                
                // Add spouses
                this.relationships
                    .filter(r => (r.from === member.id || r.to === member.id) && r.type === 'spouse')
                    .forEach(r => {
                        const spouseId = r.from === member.id ? r.to : r.from;
                        const spouse = this.members.find(m => m.id === spouseId);
                        if (spouse) {
                            this.addRelationshipToForm('spouse', spouse, r.relationshipType);
                        }
                    });
                
                // Add siblings
                this.relationships
                    .filter(r => ((r.from === member.id && r.to !== member.id) || 
                                  (r.to === member.id && r.from !== member.id)) && 
                                  r.type === 'sibling')
                    .forEach(r => {
                        const siblingId = r.from === member.id ? r.to : r.from;
                        const sibling = this.members.find(m => m.id === siblingId);
                        if (sibling) {
                            this.addRelationshipToForm('sibling', sibling, r.relationshipType);
                        }
                    });
                
                // Add children
                this.relationships
                    .filter(r => r.from === member.id && r.type === 'parent')
                    .forEach(r => {
                        const child = this.members.find(m => m.id === r.to);
                        if (child) {
                            this.addRelationshipToForm('child', child, r.relationshipType);
                        }
                    });
                
                // Update save button
                document.getElementById('save-button').textContent = 'Update Family Member';
                document.getElementById('save-button').dataset.editing = member.id;
            },
            
            // Show profile page
            showProfile: function(member) {
                this.currentMember = member;
                
                const container = document.getElementById('profile-container');
                
                // Get relationships
                const parents = this.getParents(member.id);
                const spouses = this.getSpouses(member.id);
                const siblings = this.getSiblings(member.id);
                const children = this.getChildren(member.id);
                
                let html = `
                    <div class="profile-header">
                        ${member.photo 
                            ? `<img src="${member.photo}" class="profile-picture" alt="Profile photo">`
                            : `<div class="profile-picture d-flex align-items-center justify-content-center bg-light">
                                <i class="fas fa-user fa-4x text-secondary"></i>
                              </div>`
                        }
                        <div class="profile-info">
                            <h1>${this.getDisplayName(member)}</h1>
                            ${member.gender ? `<p><strong>Gender:</strong> ${this.capitalizeFirst(member.gender)}</p>` : ''}
                            ${member.birthYear ? `<p><strong>Birth Year:</strong> ${member.birthYear}${member.deathYear ? ` - Death Year: ${member.deathYear}` : ''}</p>` : ''}
                            ${member.birthplace ? `<p><strong>Birthplace:</strong> ${member.birthplace}</p>` : ''}
                            ${member.occupation ? `<p><strong>Occupation:</strong> ${member.occupation}</p>` : ''}
                        </div>
                    </div>
                    
                    ${member.notes ? `
                    <div class="card mb-4">
                        <div class="card-header">Notes</div>
                        <div class="card-body">
                            <p>${member.notes}</p>
                        </div>
                    </div>` : ''}
                `;
                
                // Parents section
                if (parents.length > 0) {
                    html += `<h3 class="relationship-title">Parents</h3>`;
                    parents.forEach(parent => {
                        const relationshipType = this.getRelationshipType('parent', parent.id, member.id);
                        html += `
                            <div class="relationship-item" data-id="${parent.id}">
                                <div class="d-flex justify-content-between align-items-center">
                                    <div>
                                        ${parent.photo ? `<img src="${parent.photo}" class="me-2" width="30" height="30" style="border-radius: 50%; object-fit: cover;">` : ''}
                                        ${this.getDisplayName(parent)}
                                    </div>
                                    ${relationshipType ? `<span class="badge bg-info">${this.capitalizeFirst(relationshipType)}</span>` : ''}
                                </div>
                            </div>
                        `;
                    });
                }
                
                // Spouses section
                if (spouses.length > 0) {
                    html += `<h3 class="relationship-title">Spouses/Partners</h3>`;
                    spouses.forEach(spouse => {
                        const relationshipType = this.getRelationshipType('spouse', member.id, spouse.id);
                        html += `
                            <div class="relationship-item" data-id="${spouse.id}">
                                <div class="d-flex justify-content-between align-items-center">
                                    <div>
                                        ${spouse.photo ? `<img src="${spouse.photo}" class="me-2" width="30" height="30" style="border-radius: 50%; object-fit: cover;">` : ''}
                                        ${this.getDisplayName(spouse)}
                                    </div>
                                    ${relationshipType ? `<span class="badge bg-info">${this.capitalizeFirst(relationshipType)}</span>` : ''}
                                </div>
                            </div>
                        `;
                    });
                }
                
                // Siblings section
                if (siblings.length > 0) {
                    html += `<h3 class="relationship-title">Siblings</h3>`;
                    siblings.forEach(sibling => {
                        const relationshipType = this.getRelationshipType('sibling', member.id, sibling.id);
                        html += `
                            <div class="relationship-item" data-id="${sibling.id}">
                                <div class="d-flex justify-content-between align-items-center">
                                    <div>
                                        ${sibling.photo ? `<img src="${sibling.photo}" class="me-2" width="30" height="30" style="border-radius: 50%; object-fit: cover;">` : ''}
                                        ${this.getDisplayName(sibling)}
                                    </div>
                                    ${relationshipType ? `<span class="badge bg-info">${this.capitalizeFirst(relationshipType)}</span>` : ''}
                                </div>
                            </div>
                        `;
                    });
                }
                
                // Children section
                if (children.length > 0) {
                    html += `<h3 class="relationship-title">Children</h3>`;
                    children.forEach(child => {
                        const relationshipType = this.getRelationshipType('parent', member.id, child.id);
                        html += `
                            <div class="relationship-item" data-id="${child.id}">
                                <div class="d-flex justify-content-between align-items-center">
                                    <div>
                                        ${child.photo ? `<img src="${child.photo}" class="me-2" width="30" height="30" style="border-radius: 50%; object-fit: cover;">` : ''}
                                        ${this.getDisplayName(child)}
                                    </div>
                                    ${relationshipType ? `<span class="badge bg-info">${this.capitalizeFirst(relationshipType)}</span>` : ''}
                                </div>
                            </div>
                        `;
                    });
                }
                
                container.innerHTML = html;
                
                // Add click events to relationship items
                container.querySelectorAll('.relationship-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const id = item.dataset.id;
                        const person = this.members.find(m => m.id === id);
                        if (person) {
                            this.showProfile(person);
                        }
                    });
                });
                
                this.showPage('profile');
            },
            
            // Get relationship type between two people
            getRelationshipType: function(baseType, fromId, toId) {
                const relationship = this.relationships.find(r => 
                    (r.type === baseType && r.from === fromId && r.to === toId) ||
                    (r.type === baseType && r.from === toId && r.to === fromId && baseType === 'spouse') ||
                    (r.type === baseType && r.from === toId && r.to === fromId && baseType === 'sibling')
                );
                
                return relationship ? relationship.relationshipType : null;
            },
            
            // Get parents of a person
            getParents: function(personId) {
                return this.relationships
                    .filter(r => r.to === personId && r.type === 'parent')
                    .map(r => this.members.find(m => m.id === r.from))
                    .filter(Boolean);
            },
            
            // Get spouses of a person
            getSpouses: function(personId) {
                return this.relationships
                    .filter(r => (r.from === personId || r.to === personId) && r.type === 'spouse')
                    .map(r => {
                        const spouseId = r.from === personId ? r.to : r.from;
                        return this.members.find(m => m.id === spouseId);
                    })
                    .filter(Boolean);
            },
            
            // Get siblings of a person
            getSiblings: function(personId) {
                // Direct sibling relationships
                const directSiblings = this.relationships
                    .filter(r => (r.from === personId || r.to === personId) && r.type === 'sibling')
                    .map(r => {
                        const siblingId = r.from === personId ? r.to : r.from;
                        return this.members.find(m => m.id === siblingId);
                    })
                    .filter(Boolean);
                
                // Siblings through parents (same parents)
                const parents = this.getParents(personId);
                
                let parentSiblings = [];
                if (parents.length > 0) {
                    const siblingIds = new Set();
                    
                    parents.forEach(parent => {
                        // Get all children of this parent
                        const children = this.getChildren(parent.id);
                        
                        children.forEach(child => {
                            if (child.id !== personId) {
                                siblingIds.add(child.id);
                            }
                        });
                    });
                    
                    parentSiblings = Array.from(siblingIds)
                        .map(id => this.members.find(m => m.id === id))
                        .filter(Boolean);
                }
                
                // Combine both lists and remove duplicates
                const allSiblings = [...directSiblings, ...parentSiblings];
                const uniqueSiblings = Array.from(new Map(allSiblings.map(sibling => [sibling.id, sibling])).values());
                
                return uniqueSiblings;
            },
            
            // Get children of a person
            getChildren: function(personId) {
                return this.relationships
                    .filter(r => r.from === personId && r.type === 'parent')
                    .map(r => this.members.find(m => m.id === r.to))
                    .filter(Boolean);
            },
            
            // Zoom the tree
            zoomTree: function(zoomDelta) {
                const svg = d3.select('#tree-container svg');
                if (!svg.empty()) {
                    const zoom = d3.zoom();
                    
                    // Get current transform
                    let transform = d3.zoomTransform(svg.node());
                    
                    // Calculate new scale
                    this.zoomLevel = Math.max(0.1, Math.min(3, this.zoomLevel + zoomDelta));
                    
                    // Apply new transform
                    svg.call(
                        zoom.transform,
                        transform.scale(this.zoomLevel / transform.k)
                    );
                }
            },
            
            // Center the tree
            centerTree: function() {
                const svg = d3.select('#tree-container svg');
                const container = document.getElementById('tree-container');
                
                if (!svg.empty() && container) {
                    const zoom = d3.zoom();
                    const g = svg.select('g');
                    
                    if (!g.empty()) {
                        const bounds = g.node().getBBox();
                        const width = container.clientWidth;
                        const height = container.clientHeight;
                        const centerX = bounds.x + bounds.width / 2;
                        const centerY = bounds.y + bounds.height / 2;
                        
                        const scale = 0.9 / Math.max(bounds.width / width, bounds.height / height);
                        const translate = [width / 2 - scale * centerX, height / 2 - scale * centerY];
                        
                        this.zoomLevel = scale;
                        
                        svg.call(
                            zoom.transform,
                            d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
                        );
                    }
                }
            },
            
            // Populate relationship finder selects
            populateRelationshipFinderSelects: function() {
                const person1Select = document.getElementById('person1Select');
                const person2Select = document.getElementById('person2Select');
                
                // Clear existing options
                while (person1Select.options.length > 1) person1Select.remove(1);
                while (person2Select.options.length > 1) person2Select.remove(1);
                
                // Add all members as options
                this.members.forEach(member => {
                    const option1 = document.createElement('option');
                    option1.value = member.id;
                    option1.textContent = this.getDisplayName(member);
                    person1Select.appendChild(option1);
                    
                    const option2 = document.createElement('option');
                    option2.value = member.id;
                    option2.textContent = this.getDisplayName(member);
                    person2Select.appendChild(option2);
                });
            },
            
            // Find relationship between two people
            findRelationship: function() {
                const person1Id = document.getElementById('person1Select').value;
                const person2Id = document.getElementById('person2Select').value;
                const resultContainer = document.getElementById('relationship-result');
                
                if (!person1Id || !person2Id) {
                    resultContainer.innerHTML = '<div class="alert alert-warning">Please select two people</div>';
                    return;
                }
                
                if (person1Id === person2Id) {
                    resultContainer.innerHTML = '<div class="alert alert-info">Same person selected</div>';
                    return;
                }
                
                const person1 = this.members.find(m => m.id === person1Id);
                const person2 = this.members.find(m => m.id === person2Id);
                
                if (!person1 || !person2) {
                    resultContainer.innerHTML = '<div class="alert alert-danger">Error finding selected people</div>';
                    return;
                }
                
                // Check direct relationships first
                const directRelationship = this.getDirectRelationship(person1Id, person2Id);
                if (directRelationship) {
                    resultContainer.innerHTML = `
                        <div class="alert alert-success">
                            <h5 class="alert-heading">Direct Relationship Found!</h5>
                            <p>${this.getDisplayName(person1)} is ${directRelationship} of ${this.getDisplayName(person2)}</p>
                        </div>
                    `;
                    return;
                }
                
                // Check if they are siblings
                if (this.areSiblings(person1Id, person2Id)) {
                    const siblingType = this.getSiblingType(person1Id, person2Id);
                    resultContainer.innerHTML = `
                        <div class="alert alert-success">
                            <h5 class="alert-heading">Sibling Relationship Found!</h5>
                            <p>${this.getDisplayName(person1)} is a ${siblingType || ''} sibling of ${this.getDisplayName(person2)}</p>
                        </div>
                    `;
                    return;
                }
                
                // Check if one is a grandparent of the other
                if (this.isGrandparent(person1Id, person2Id)) {
                    resultContainer.innerHTML = `
                        <div class="alert alert-success">
                            <h5 class="alert-heading">Grandparent Relationship Found!</h5>
                            <p>${this.getDisplayName(person1)} is a grandparent of ${this.getDisplayName(person2)}</p>
                        </div>
                    `;
                    return;
                }
                
                if (this.isGrandparent(person2Id, person1Id)) {
                    resultContainer.innerHTML = `
                        <div class="alert alert-success">
                            <h5 class="alert-heading">Grandparent Relationship Found!</h5>
                            <p>${this.getDisplayName(person2)} is a grandparent of ${this.getDisplayName(person1)}</p>
                        </div>
                    `;
                    return;
                }
                
                // Check if they are cousins
                const cousinResult = this.findCousinRelationship(person1Id, person2Id);
                if (cousinResult) {
                    resultContainer.innerHTML = `
                        <div class="alert alert-success">
                            <h5 class="alert-heading">Cousin Relationship Found!</h5>
                            <p>${cousinResult}</p>
                        </div>
                    `;
                    return;
                }
                
                // Check in-law relationships
                const inLawRelationship = this.findInLawRelationship(person1Id, person2Id);
                if (inLawRelationship) {
                    resultContainer.innerHTML = `
                        <div class="alert alert-success">
                            <h5 class="alert-heading">In-Law Relationship Found!</h5>
                            <p>${inLawRelationship}</p>
                        </div>
                    `;
                    return;
                }
                
                // If no relationship found
                resultContainer.innerHTML = `
                    <div class="alert alert-info">
                        <h5 class="alert-heading">No Clear Relationship Found</h5>
                        <p>No direct family relationship was found between ${this.getDisplayName(person1)} and ${this.getDisplayName(person2)}</p>
                    </div>
                `;
            },
            
            // Get direct relationship between two people
            getDirectRelationship: function(person1Id, person2Id) {
                // Check parent-child
                const isParent = this.relationships.some(r => 
                    r.from === person1Id && r.to === person2Id && r.type === 'parent'
                );
                
                if (isParent) {
                    return 'a parent';
                }
                
                const isChild = this.relationships.some(r => 
                    r.from === person2Id && r.to === person1Id && r.type === 'parent'
                );
                
                if (isChild) {
                    return 'a child';
                }
                
                // Check spouse
                const isSpouse = this.relationships.some(r => 
                    ((r.from === person1Id && r.to === person2Id) || 
                     (r.from === person2Id && r.to === person1Id)) && 
                    r.type === 'spouse'
                );
                
                if (isSpouse) {
                    const relationship = this.relationships.find(r => 
                        ((r.from === person1Id && r.to === person2Id) || 
                         (r.from === person2Id && r.to === person1Id)) && 
                        r.type === 'spouse'
                    );
                    
                    if (relationship && relationship.relationshipType) {
                        switch (relationship.relationshipType) {
                            case 'married': return 'married to';
                            case 'divorced': return 'divorced from';
                            case 'partner': return 'a partner of';
                            case 'separated': return 'separated from';
                            default: return 'a spouse of';
                        }
                    }
                    
                    return 'a spouse of';
                }
                
                return null;
            },
            
            // Check if two people are siblings
            areSiblings: function(person1Id, person2Id) {
                // Direct sibling relationship
                const directSibling = this.relationships.some(r => 
                    ((r.from === person1Id && r.to === person2Id) || 
                     (r.from === person2Id && r.to === person1Id)) && 
                    r.type === 'sibling'
                );
                
                if (directSibling) {
                    return true;
                }
                
                // Check if they share parents
                const parents1 = this.getParents(person1Id).map(p => p.id);
                const parents2 = this.getParents(person2Id).map(p => p.id);
                
                // If they share at least one parent, they are siblings
                return parents1.some(p => parents2.includes(p));
            },
            
            // Get sibling type
            getSiblingType: function(person1Id, person2Id) {
                // Check direct sibling relationship first
                const siblingRel = this.relationships.find(r => 
                    ((r.from === person1Id && r.to === person2Id) || 
                     (r.from === person2Id && r.to === person1Id)) && 
                    r.type === 'sibling'
                );
                
                if (siblingRel && siblingRel.relationshipType) {
                    return siblingRel.relationshipType;
                }
                
                // Otherwise, check parents
                const parents1 = this.getParents(person1Id);
                const parents2 = this.getParents(person2Id);
                
                const parentIds1 = parents1.map(p => p.id);
                const parentIds2 = parents2.map(p => p.id);
                
                const commonParents = parentIds1.filter(id => parentIds2.includes(id));
                
                if (commonParents.length === 0) {
                    return null;
                }
                
                if (parents1.length === parents2.length && commonParents.length === parents1.length) {
                    return 'full';
                } else {
                    return 'half';
                }
            },
            
            // Check if person1 is a grandparent of person2
            isGrandparent: function(person1Id, person2Id) {
                // Get children of person1
                const children = this.getChildren(person1Id).map(c => c.id);
                
                // Get parents of person2
                const parents = this.getParents(person2Id).map(p => p.id);
                
                // If any child of person1 is a parent of person2, then person1 is a grandparent
                return children.some(childId => parents.includes(childId));
            },
            
            // Find cousin relationship
            findCousinRelationship: function(person1Id, person2Id) {
                // Get parents
                const parents1 = this.getParents(person1Id);
                const parents2 = this.getParents(person2Id);
                
                // Check if parents are siblings (making these two first cousins)
                for (const parent1 of parents1) {
                    for (const parent2 of parents2) {
                        if (this.areSiblings(parent1.id, parent2.id)) {
                            return `${this.getDisplayName(person1)} and ${this.getDisplayName(person2)} are first cousins`;
                        }
                    }
                }
                
                // TODO: Could extend this to check for second cousins, etc.
                return null;
            },
            
            // Find in-law relationships
            findInLawRelationship: function(person1Id, person2Id) {
                // Get spouses
                const spouses1 = this.getSpouses(person1Id);
                const spouses2 = this.getSpouses(person2Id);
                
                // Check if one is a parent of the other's spouse
                for (const spouse of spouses1) {
                    if (this.getParents(spouse.id).map(p => p.id).includes(person2Id)) {
                        return `${this.getDisplayName(person2)} is a parent-in-law of ${this.getDisplayName(person1)}`;
                    }
                }
                
                for (const spouse of spouses2) {
                    if (this.getParents(spouse.id).map(p => p.id).includes(person1Id)) {
                        return `${this.getDisplayName(person1)} is a parent-in-law of ${this.getDisplayName(person2)}`;
                    }
                }
                
                // Check if one is a sibling of the other's spouse
                for (const spouse of spouses1) {
                    if (this.areSiblings(spouse.id, person2Id)) {
                        return `${this.getDisplayName(person2)} is a sibling-in-law of ${this.getDisplayName(person1)}`;
                    }
                }
                
                for (const spouse of spouses2) {
                    if (this.areSiblings(spouse.id, person1Id)) {
                        return `${this.getDisplayName(person1)} is a sibling-in-law of ${this.getDisplayName(person2)}`;
                    }
                }
                
                return null;
            },
            
            // Build family tree data structure
            buildFamilyTreeData: function() {
                if (this.members.length === 0) return null;
                
                // Create a map to deduplicate members
                const processedMembers = new Map();
                
                // Find people without parents (root nodes)
                const rootMemberIds = this.members
                    .filter(member => {
                        return !this.relationships.some(r => r.to === member.id && r.type === 'parent');
                    })
                    .map(member => member.id);
                
                if (rootMemberIds.length === 0 && this.members.length > 0) {
                    // If there are no clear root nodes but we have members,
                    // take the oldest members (by birth year) as roots
                    const sortedMembers = [...this.members].sort((a, b) => {
                        const yearA = a.birthYear ? parseInt(a.birthYear) : 9999;
                        const yearB = b.birthYear ? parseInt(b.birthYear) : 9999;
                        return yearA - yearB;
                    });
                    
                    // Take the oldest 5% or at least one
                    const numRoots = Math.max(1, Math.ceil(sortedMembers.length * 0.05));
                    return sortedMembers.slice(0, numRoots).map(member => member.id);
                }
                
                // Process each root node to create family units
                const familyUnits = [];
                
                rootMemberIds.forEach(rootId => {
                    // Get the root person
                    const rootPerson = this.members.find(m => m.id === rootId);
                    
                    // Find all spouses of the root person
                    const spouseIds = this.relationships
                        .filter(r => (r.from === rootId || r.to === rootId) && r.type === 'spouse')
                        .map(r => r.from === rootId ? r.to : r.from);
                    
                    if (spouseIds.length === 0) {
                        // Person without spouse
                        const familyUnit = {
                            id: `family_${rootId}`,
                            parents: [rootPerson],
                            children: this.getChildrenFamilyUnits(rootId, processedMembers)
                        };
                        
                        familyUnits.push(familyUnit);
                    } else {
                        // Process each marriage
                        spouseIds.forEach(spouseId => {
                            const spouse = this.members.find(m => m.id === spouseId);
                            
                            // Find children from this marriage
                            const childrenUnits = this.getCommonChildrenFamilyUnits(rootId, spouseId, processedMembers);
                            
                            const familyUnit = {
                                id: `family_${rootId}_${spouseId}`,
                                parents: [rootPerson, spouse],
                                children: childrenUnits
                            };
                            
                            familyUnits.push(familyUnit);
                        });
                    }
                });
                
                return familyUnits;
            },
            
            // Get children of a person as family units
            getChildrenFamilyUnits: function(parentId) {
                // Find all children of this parent
                const childrenIds = this.relationships
                    .filter(r => r.from === parentId && r.type === 'parent')
                    .map(r => r.to);
                
                if (childrenIds.length === 0) return [];
                
                const childrenUnits = [];
                
                // Process each child
                childrenIds.forEach(childId => {
                    const child = this.members.find(m => m.id === childId);
                    
                    // Find all spouses of this child
                    const spouseIds = this.relationships
                        .filter(r => (r.from === childId || r.to === childId) && r.type === 'spouse')
                        .map(r => r.from === childId ? r.to : r.from);
                    
                    if (spouseIds.length === 0) {
                        // Child without spouse
                        const childUnit = {
                            id: `family_${childId}`,
                            parents: [child],
                            children: this.getChildrenFamilyUnits(childId)
                        };
                        
                        childrenUnits.push(childUnit);
                    } else {
                        // Process each marriage of the child
                        spouseIds.forEach(spouseId => {
                            const spouse = this.members.find(m => m.id === spouseId);
                            
                            // Find children from this marriage
                            const grandchildrenUnits = this.getCommonChildrenFamilyUnits(childId, spouseId);
                            
                            const childUnit = {
                                id: `family_${childId}_${spouseId}`,
                                parents: [child, spouse],
                                children: grandchildrenUnits
                            };
                            
                            childrenUnits.push(childUnit);
                        });
                    }
                });
                
                return childrenUnits;
            },
            
            // Get common children of two parents as family units
            getCommonChildrenFamilyUnits: function(parent1Id, parent2Id) {
                // Find children with both parents
                const children1 = this.relationships
                    .filter(r => r.from === parent1Id && r.type === 'parent')
                    .map(r => r.to);
                
                const children2 = this.relationships
                    .filter(r => r.from === parent2Id && r.type === 'parent')
                    .map(r => r.to);
                
                // Find intersection (common children)
                const commonChildrenIds = children1.filter(id => children2.includes(id));
                
                // If no common children, check for all children of parent1
                const allChildrenIds = commonChildrenIds.length > 0 ? commonChildrenIds : children1;
                
                if (allChildrenIds.length === 0) return [];
                
                const childrenUnits = [];
                
                // Process each child
                allChildrenIds.forEach(childId => {
                    const child = this.members.find(m => m.id === childId);
                    
                    // Find all spouses of this child
                    const spouseIds = this.relationships
                        .filter(r => (r.from === childId || r.to === childId) && r.type === 'spouse')
                        .map(r => r.from === childId ? r.to : r.from);
                    
                    if (spouseIds.length === 0) {
                        // Child without spouse
                        const childUnit = {
                            id: `family_${childId}`,
                            parents: [child],
                            children: this.getChildrenFamilyUnits(childId)
                        };
                        
                        childrenUnits.push(childUnit);
                    } else {
                        // Process each marriage of the child
                        spouseIds.forEach(spouseId => {
                            const spouse = this.members.find(m => m.id === spouseId);
                            
                            // Find children from this marriage
                            const grandchildrenUnits = this.getCommonChildrenFamilyUnits(childId, spouseId);
                            
                            const childUnit = {
                                id: `family_${childId}_${spouseId}`,
                                parents: [child, spouse],
                                children: grandchildrenUnits
                            };
                            
                            childrenUnits.push(childUnit);
                        });
                    }
                });
                
                return childrenUnits;
            },
            
            // Render the family tree
            renderTree: function(forceReorganize = false) {
                const container = document.getElementById('tree-container');
                container.innerHTML = '';
                
                if (this.members.length === 0) {
                    container.innerHTML = `
                        <div class="d-flex flex-column align-items-center justify-content-center h-100">
                            <h3 class="text-muted mb-4">No family members yet</h3>
                            <button id="start-adding-button" class="btn btn-primary">Add Your First Family Member</button>
                        </div>
                    `;
                    
                    document.getElementById('start-adding-button').addEventListener('click', () => {
                        this.resetForm();
                        this.showPage('form');
                    });
                    
                    return;
                }
                
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                // Define tree layout parameters
                const boxWidth = 120;
                const boxHeight = 40;
                const levelHeight = 120;
                const siblingDistance = 20;
                
                // Create SVG container
                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                // Add zoom behavior
                const zoom = d3.zoom()
                    .scaleExtent([0.1, 3])
                    .on('zoom', (event) => {
                        g.attr('transform', event.transform);
                    });
                
                svg.call(zoom);
                
                // Create main group for zooming
                const g = svg.append('g');
                
                // Get tree data
                const familyUnits = this.buildFamilyTreeData();
                
                if (!familyUnits || familyUnits.length === 0) {
                    container.innerHTML = `
                        <div class="d-flex flex-column align-items-center justify-content-center h-100">
                            <h3 class="text-muted mb-4">Could not create family tree structure</h3>
                            <p class="text-center">Try adding more family members with clear parent-child relationships.</p>
                        </div>
                    `;
                    return;
                }
                
                // Calculate positions
                const rootUnits = this.layoutFamilyTree(familyUnits, 0, width / 2, 0, boxWidth, boxHeight, levelHeight, siblingDistance);
                
                // Draw units recursively
                this.drawFamilyUnits(g, rootUnits, boxWidth, boxHeight);
                
                // Center the view
                const bounds = g.node().getBBox();
                const centerX = bounds.x + bounds.width / 2;
                const centerY = bounds.y + bounds.height / 2;
                
                const scale = 0.9 / Math.max(bounds.width / width, bounds.height / height);
                const translate = [width / 2 - scale * centerX, height / 2 - scale * centerY];
                
                this.zoomLevel = scale;
                
                svg.call(zoom.transform, d3.zoomIdentity
                    .translate(translate[0], translate[1])
                    .scale(scale));
            },
            
            // Layout family tree by calculating positions
            layoutFamilyTree: function(units, level, startX, startY, boxWidth, boxHeight, levelHeight, siblingDistance) {
                if (!units || units.length === 0) return [];
                
                const spacedUnits = [];
                let currentX = startX - ((units.length - 1) * (boxWidth + siblingDistance)) / 2;
                
                // Position each unit and its children
                units.forEach(unit => {
                    // Position children recursively first to know how wide they are
                    let childrenPositioned = [];
                    if (unit.children && unit.children.length > 0) {
                        childrenPositioned = this.layoutFamilyTree(
                            unit.children, 
                            level + 1, 
                            currentX, 
                            startY, 
                            boxWidth, 
                            boxHeight, 
                            levelHeight, 
                            siblingDistance
                        );
                    }
                    
                    // Calculate the center X position based on children
                    let unitX = currentX;
                    if (childrenPositioned.length > 0) {
                        const leftMostChild = childrenPositioned[0];
                        const rightMostChild = childrenPositioned[childrenPositioned.length - 1];
                        const childrenCenter = (leftMostChild.x + rightMostChild.x) / 2;
                        unitX = childrenCenter;
                    }
                    
                    // Create a copy with position
                    const positionedUnit = {
                        ...unit,
                        x: unitX,
                        y: startY + level * levelHeight,
                        level: level,
                        children: childrenPositioned
                    };
                    
                    spacedUnits.push(positionedUnit);
                    currentX += boxWidth + siblingDistance;
                });
                
                // Adjust for overlaps
                for (let i = 1; i < spacedUnits.length; i++) {
                    const prevUnit = spacedUnits[i-1];
                    const currUnit = spacedUnits[i];
                    
                    const minDistance = boxWidth + siblingDistance;
                    if (currUnit.x - prevUnit.x < minDistance) {
                        const shift = minDistance - (currUnit.x - prevUnit.x);
                        currUnit.x += shift;
                        
                        // Shift all subsequent units
                        for (let j = i + 1; j < spacedUnits.length; j++) {
                            spacedUnits[j].x += shift;
                        }
                    }
                }
                
                return spacedUnits;
            },
            
            // Draw family units recursively
            drawFamilyUnits: function(svg, units, boxWidth, boxHeight) {
                if (!units || units.length === 0) return;
                
                units.forEach(unit => {
                    // Draw family unit
                    this.drawFamilyUnit(svg, unit, boxWidth, boxHeight);
                    
                    // Draw connections to children
                    if (unit.children && unit.children.length > 0) {
                        // Draw connection line down from this unit
                        const lineStartY = unit.y + boxHeight;
                        const lineEndY = unit.children[0].y - 20; // Adjust based on your layout
                        
                        // Vertical line down from parents
                        svg.append('path')
                            .attr('class', 'tree-link')
                            .attr('d', `M${unit.x + boxWidth/2},${lineStartY} V${lineEndY}`);
                        
                        // Horizontal line connecting all children if more than one
                        if (unit.children.length > 1) {
                            const leftMostChild = unit.children[0];
                            const rightMostChild = unit.children[unit.children.length - 1];
                            
                            svg.append('path')
                                .attr('class', 'tree-link')
                                .attr('d', `M${leftMostChild.x + boxWidth/2},${lineEndY} H${rightMostChild.x + boxWidth/2}`);
                        }
                        
                        // Vertical lines to each child
                        unit.children.forEach(child => {
                            svg.append('path')
                                .attr('class', 'tree-link')
                                .attr('d', `M${child.x + boxWidth/2},${lineEndY} V${child.y}`);
                        });
                        
                        // Recursively draw children
                        this.drawFamilyUnits(svg, unit.children, boxWidth, boxHeight);
                    }
                });
            },
            
            // Draw a single family unit
            drawFamilyUnit: function(svg, unit, boxWidth, boxHeight) {
                const parents = unit.parents;
                
                if (parents.length === 0) return;
                
                // Create group for this family unit
                const familyGroup = svg.append('g')
                    .attr('class', 'family-unit')
                    .attr('transform', `translate(${unit.x},${unit.y})`);
                
                // Draw parents
                if (parents.length === 1) {
                    // Single parent
                    const parent = parents[0];
                    this.drawPersonNode(familyGroup, parent, boxWidth / 2, 0, boxWidth, boxHeight);
                } else if (parents.length === 2) {
                    // Two parents (marriage)
                    const spacing = 20; // Space between spouses
                    const totalWidth = boxWidth * 2 + spacing;
                    
                    // Draw first parent
                    this.drawPersonNode(
                        familyGroup, 
                        parents[0], 
                        0, 
                        0, 
                        boxWidth, 
                        boxHeight
                    );
                    
                    // Draw second parent
                    this.drawPersonNode(
                        familyGroup, 
                        parents[1], 
                        boxWidth + spacing, 
                        0, 
                        boxWidth, 
                        boxHeight
                    );
                    
                    // Draw marriage line
                    familyGroup.append('path')
                        .attr('class', 'marriage-link')
                        .attr('d', `M${boxWidth},${boxHeight/2} H${boxWidth + spacing}`);
                }
            },
            
            // Draw a person node
            drawPersonNode: function(group, person, x, y, width, height) {
                const nodeGroup = group.append('g')
                    .attr('class', 'family-node')
                    .attr('transform', `translate(${x},${y})`)
                    .attr('data-id', person.id)
                    .style('cursor', 'pointer')
                    .on('click', (event) => {
                        // Find the member from the clicked node
                        const id = event.currentTarget.getAttribute('data-id');
                        const member = this.members.find(m => m.id === id);
                        if (member) {
                            this.showProfile(member);
                        }
                    });
                
                // Add background rectangle/ellipse for node with white background for better text contrast
                let nodeShape;
                if (person.gender === 'male') {
                    // Background for photo/text
                    nodeGroup.append('rect')
                        .attr('width', width)
                        .attr('height', height)
                        .attr('rx', 5)
                        .attr('fill', 'white')
                        .attr('stroke', '#4A89DC')
                        .attr('stroke-width', 1);
                    
                    // Actual colored shape
                    nodeShape = nodeGroup.append('rect')
                        .attr('class', 'node-male')
                        .attr('width', width)
                        .attr('height', height)
                        .attr('rx', 5)
                        .attr('fill-opacity', 0.8);
                } else if (person.gender === 'female') {
                    // Background for photo/text
                    nodeGroup.append('ellipse')
                        .attr('cx', width / 2)
                        .attr('cy', height / 2)
                        .attr('rx', width / 2)
                        .attr('ry', height / 2)
                        .attr('fill', 'white')
                        .attr('stroke', '#D770AD')
                        .attr('stroke-width', 1);
                    
                    // Actual colored shape
                    nodeShape = nodeGroup.append('ellipse')
                        .attr('class', 'node-female')
                        .attr('cx', width / 2)
                        .attr('cy', height / 2)
                        .attr('rx', width / 2)
                        .attr('ry', height / 2)
                        .attr('fill-opacity', 0.8);
                } else {
                    // Background for photo/text
                    nodeGroup.append('polygon')
                        .attr('points', `${width/2},0 ${width},${height/2} ${width/2},${height} 0,${height/2}`)
                        .attr('fill', 'white')
                        .attr('stroke', '#656D78')
                        .attr('stroke-width', 1);
                    
                    // Actual colored shape
                    nodeShape = nodeGroup.append('polygon')
                        .attr('class', 'node-unknown')
                        .attr('points', `${width/2},0 ${width},${height/2} ${width/2},${height} 0,${height/2}`)
                        .attr('fill-opacity', 0.8);
                }
                
                // Add photo directly into the node (not as a separate element)
                if (person.photo) {
                    // Create a clip path for the photo
                    const clipId = `clip-${person.id}`;
                    const defs = group.append('defs');
                    const clipPath = defs.append('clipPath').attr('id', clipId);
                    
                    // Create appropriate clip shape based on gender
                    if (person.gender === 'male') {
                        clipPath.append('rect')
                            .attr('x', width/2 - 25)
                            .attr('y', -30)
                            .attr('width', 50)
                            .attr('height', 50)
                            .attr('rx', 5);
                    } else if (person.gender === 'female') {
                        clipPath.append('circle')
                            .attr('cx', width/2)
                            .attr('cy', -15)
                            .attr('r', 25);
                    } else {
                        clipPath.append('circle')
                            .attr('cx', width/2)
                            .attr('cy', -15)
                            .attr('r', 25);
                    }
                    
                    // Add background for the photo
                    nodeGroup.append('rect')
                        .attr('x', width/2 - 28)
                        .attr('y', -33)
                        .attr('width', 56)
                        .attr('height', 56)
                        .attr('rx', 28)
                        .attr('fill', 'white')
                        .attr('stroke', '#ccc')
                        .attr('stroke-width', 2);
                    
                    // Add the actual photo
                    nodeGroup.append('image')
                        .attr('x', width/2 - 25)
                        .attr('y', -30)
                        .attr('width', 50)
                        .attr('height', 50)
                        .attr('clip-path', `url(#${clipId})`)
                        .attr('xlink:href', person.photo);
                }
                
                // Add name
                nodeGroup.append('text')
                    .attr('x', width / 2)
                    .attr('y', height / 2 + 5)
                    .attr('text-anchor', 'middle')
                    .attr('fill', 'black')
                    .attr('font-weight', 'bold')
                    .attr('font-size', '14px')
                    .text(this.getShortName(person));
                
                // Add birth/death year with better visibility
                if (person.birthYear) {
                    let yearText = person.birthYear;
                    if (person.deathYear) {
                        yearText += `-${person.deathYear}`;
                    }
                    
                    // Add white background for year text
                    nodeGroup.append('rect')
                        .attr('x', width / 2 - 30)
                        .attr('y', height + 10)
                        .attr('width', 60)
                        .attr('height', 20)
                        .attr('rx', 4)
                        .attr('fill', 'white')
                        .attr('fill-opacity', 0.8)
                        .attr('stroke', '#ccc')
                        .attr('stroke-width', 1);
                    
                    nodeGroup.append('text')
                        .attr('class', 'node-year-label')
                        .attr('x', width / 2)
                        .attr('y', height + 24)
                        .text(yearText);
                }
                
                // Add delete button (X)
                const deleteBtn = nodeGroup.append('g')
                    .attr('class', 'delete-button')
                    .attr('transform', `translate(${width - 5}, 0)`)
                    .style('cursor', 'pointer')
                    .on('click', (event) => {
                        event.stopPropagation(); // Prevent opening profile when clicking delete
                        
                        const id = nodeGroup.attr('data-id');
                        if (confirm('Are you sure you want to delete this person?')) {
                            this.deleteMember(id);
                        }
                    });
                
                deleteBtn.append('circle')
                    .attr('cx', 0)
                    .attr('cy', 0)
                    .attr('r', 10)
                    .attr('fill', 'white')
                    .attr('stroke', '#e74c3c')
                    .attr('stroke-width', 1);
                
                deleteBtn.append('text')
                    .attr('x', 0)
                    .attr('y', 4)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#e74c3c')
                    .attr('font-weight', 'bold')
                    .text('');
            },
            
            // Delete a family member
            deleteMember: function(memberId) {
                // Find the member
                const memberIndex = this.members.findIndex(m => m.id === memberId);
                if (memberIndex === -1) return;
                
                // Remove the member
                this.members.splice(memberIndex, 1);
                
                // Remove all relationships involving this member
                this.relationships = this.relationships.filter(r => 
                    r.from !== memberId && r.to !== memberId
                );
                
                // Save data and re-render
                this.saveData();
                this.populateMemberSelectors();
                this.renderTree();
            },
            
            // Utility functions
            getDisplayName: function(member) {
                if (!member) return 'Unknown';
                
                let name = member.firstName || '';
                if (member.middleName) name += ' ' + member.middleName;
                if (member.lastName) name += ' ' + member.lastName;
                
                return name.trim() || 'Unnamed';
            },
            
            getShortName: function(member) {
                if (!member) return '';
                
                // Just first name for space reasons
                return member.firstName || (member.lastName || 'Unnamed');
            },
            
            capitalizeFirst: function(str) {
                return str.charAt(0).toUpperCase() + str.slice(1);
            },
            
            generateUniqueId: function() {
                return Date.now().toString(36) + Math.random().toString(36).substring(2);
            }
        };
        
        // Initialize when document is loaded
        document.addEventListener('DOMContentLoaded', function() {
            familyTreeApp.init();
            
            // Additional click handlers for reliability
            document.querySelectorAll('button').forEach(button => {
                const id = button.id;
                
                switch(id) {
                    case 'start-button':
                        button.onclick = () => familyTreeApp.showPage('form');
                        break;
                    case 'import-button':
                        button.onclick = () => document.getElementById('import-file').click();
                        break;
                    case 'cancel-button':
                        button.onclick = () => {
                            if (familyTreeApp.members.length > 0) {
                                familyTreeApp.showPage('tree');
                            } else {
                                familyTreeApp.showPage('welcome');
                            }
                        };
                        break;
                    case 'reset-button':
                        button.onclick = () => familyTreeApp.resetForm();
                        break;
                    case 'save-button':
                        button.onclick = () => familyTreeApp.saveMember();
                        break;
                    case 'add-member-button':
                        button.onclick = () => {
                            familyTreeApp.resetForm();
                            familyTreeApp.showPage('form');
                        };
                        break;
                    case 'add-member-floating':
                        button.onclick = () => {
                            familyTreeApp.resetForm();
                            familyTreeApp.showPage('form');
                        };
                        break;
                    case 'export-button':
                        button.onclick = () => familyTreeApp.exportData();
                        break;
                    case 'back-to-tree-button':
                        button.onclick = () => familyTreeApp.showPage('tree');
                        break;
                    case 'organize-tree-button':
                        button.onclick = () => familyTreeApp.renderTree(true);
                        break;
                    case 'zoom-in-button':
                        button.onclick = () => familyTreeApp.zoomTree(0.2);
                        break;
                    case 'zoom-out-button':
                        button.onclick = () => familyTreeApp.zoomTree(-0.2);
                        break;
                    case 'center-tree-button':
                        button.onclick = () => familyTreeApp.centerTree();
                        break;
                }
            });
        });
    </script>
</body>
</html>
